import getopt
import json
import sys

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
from scipy.io.wavfile import read
from tqdm import tqdm

from eq import create_filter, process_signal


def help():
    print(
        'Usage: python analyzer.py -p {profile_path} -i {input_file_path} -o {output_file_path} [optional parameters]'
    )
    print('\tParameters:')
    print(
        '\t\t-p [--profile=]: sets the path for the profile file. The file must be a `.json` in the format generated by equapyzer'
    )
    print('\t\t-i [--iput=]: path to the input `.wav`')
    print('\t\t-o [--output=]: path to the output')
    print('\tOptional parameters:')
    print('\t\t-h [--help]: displays this message')
    print(
        '\t\t-f [--frequency] update frequency of the created animation (fps) [default=10]'
    )
    print('\t\t-d [--display] display interval of saving progress (default=10)')
    print('\t\t-b [--buffer] buffer size, size of the FFT window in samples (default=512)')
    sys.exit()


def init():
    axs[0, 0].set(title='Input sound', xlabel='time (s)', ylabel='Magnitude')
    axs[0, 0].set_ylim(1.2 * min, 1.2 * max)
    
    axs[0, 1].set_xlim(0, 22000)
    axs[0, 1].set_ylim(-20, 5)
    

    axs[1, 0].set(title='Output sound', xlabel='time (s)', ylabel='Magnitude')
    axs[1, 0].set_ylim(1.2 * min, 1.2 * max)

    axs[1, 1].set_xlim(0, 20000)
    axs[1, 1].set_ylim(-20, 5)


def update(frame):
    for i in range(frame * buff_size, (frame + 1) * buff_size):
        xdata.append(xframes[i])
        ydata.append(yframes[i])
    axs[0, 0].set_xlim(frame * buff_size * dt, (frame + 1) * buff_size * dt)
    line[0].set_data(xdata, ydata)

    fft = np.abs(np.fft.fft(yframes[frame * buff_size : (frame + 1) * buff_size]))
    x = np.fft.fftfreq(len(fft), d=dt)
    fft, x = fft[: len(fft) // 2], x[: len(fft) // 2]
    reference = 2 * np.sum(fft)
    y = 10 * np.log10(fft / reference)
    axs[0, 1].clear()
    axs[0, 1].semilogx(x, y)
    axs[0, 1].set(
        title='Input sound spectrum',
        xlabel='Frequency (Hz)',
        ylabel='Magnitude (dB)',
        xlim=(20, 20000),
        ylim=(-20, 5),
    )
    axs[0, 1].set_xticks(
        [20, 100, 1000, 2000, 10000, 20000],
        ['20', '100', '1K', '2K', '10K', '20K'],
    )
    line[1].set_data(x, y)

    output = process_signal(
        yframes[frame * buff_size : (frame + 1) * buff_size], filter, gain=1
    )

    for out in output:
        yout.append(out)
    axs[1, 0].set_xlim(frame * buff_size * dt, (frame + 1) * buff_size * dt)
    line[2].set_data(xdata, yout)

    fft = np.abs(np.fft.fft(output))
    x = np.fft.fftfreq(len(fft), d=dt)
    fft, x = fft[: len(fft) // 2], x[: len(fft) // 2]
    reference = 2 * np.sum(fft)
    y = 10 * np.log10(fft / reference)
    axs[1, 1].clear()
    axs[1, 1].semilogx(x, y)
    axs[1, 1].set(
        title='Output sound spectrum',
        xlabel='Frequency (Hz)',
        ylabel='Magnitude (dB)',
        xlim=(20, 20000),
        ylim=(-20, 5),
    )
    axs[1, 1].set_xticks(
        [20, 100, 1000, 2000, 10000, 20000],
        ['20', '100', '1K', '2K', '10K', '20K'],
    )
    line[3].set_data(x, y)
    return line


# Get cli arguments
argv = sys.argv[1:]
try:
    opts, args = getopt.gnu_getopt(
        argv,
        'p:i:o:h:f:d:b:',
        ['profile=', 'input=', 'output=', 'help', 'frequency=', 'display=', 'buffer='],
    )
except:
    help()

profile_path, input_path, output_path = None, None, None
frequency, display = 10, 10
buff_size = 512
for opt, value in opts:
    if opt in ['-h', '--helpt']:
        help()
    elif opt in ['-p', '--profile']:
        profile_path = value
    elif opt in ['-i', '--input']:
        input_path = value
    elif opt in ['-o', '--output']:
        output_path = value
    elif opt in ['-f', '--frequency']:
        try:
            frequency = int(value)
        except ValueError:
            print('Frequency value must be an integer!')
            help()
    elif opt in ['-d', '--display']:
        try:
            display = int(value)
        except ValueError:
            print('Display interval must be an integer!')
            help()
    elif opt in ['-b', '--buffer']:
        try:
            buff_size = int(value)
        except ValueError:
            print('Buffer size must be an integer!')
            help()

if profile_path is None or input_path is None or output_path is None:
    help()


plt.ion()
np.seterr(all="ignore")

# Configure animation plots
fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(16, 10))
xdata, ydata, yout = [], [], []
(ln1,) = axs[0, 0].plot([], [])
(ln2,) = axs[0, 1].plot([], [])
(ln3,) = axs[1, 0].plot([], [])
(ln4,) = axs[1, 1].plot([], [])
line = [ln1, ln2, ln3, ln4]

# Get .wav data
Fs, s = read(input_path)
try:
    if s.shape[1] != 1:
        s = s[:, 0]
except IndexError:
    ...

# Sound info
max, min = max(s), min(s)
dt = 1 / Fs
n_buffs = len(s) // buff_size
time = len(s) * dt
xframes = np.linspace(0, time, len(s))
yframes = s

# Get equalizer data
with open(profile_path, 'r') as f:
    gains = json.loads(f.read())
freqs, gains = list(map(int, gains.keys())), list(gains.values())
freqs.insert(0, 0)
freqs.append(Fs / 2)
gains.insert(0, 0)
gains.append(-100)
filter = create_filter(freqs, gains, Fs, 2**16 - 1)

# Create and save animation
p_bar = tqdm(range(n_buffs), desc='Saving animation')
ani = FuncAnimation(
    fig,
    update,
    frames=range(n_buffs),
    init_func=init,
    repeat=False,
    interval=1000 / frequency,
)
ani.save(output_path, progress_callback=lambda curr, total: p_bar.update())
